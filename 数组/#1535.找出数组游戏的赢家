/*
给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。

每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。

返回赢得比赛的整数。

题目数据 保证 游戏存在赢家。   这题的坑:k可以>arr.length,此时要返回数组内最大值,还有不要真的移动数组中元素...会超时的,并且只要求返回赢得比赛的整数即可,你移它干吗呢

别人的思路:我们注意到，每次会比较数组的前两个元素，不管结果怎么样，下一次的比较，一定是轮到了数组中的下一个元素和当前的胜者进行比较。因此，如果循环了 n−1n-1n−1 次，
那么最后的胜者一定是数组中的最大元素。否则，如果某个元素连续胜出了 kkk 次，那么这个元素就是最后的胜者。

我的思路:一开始用while(k!=cnt)套了个for(i<k+1),还每一步都挪数组,完全实现了游戏的进行,但实际没必要,
        看完最优解后直接max保存数组首位,往后遍历至尾,大于arr[i]则cnt++,小于arr[i]则更新max(arr[i])和cnt(1),继续向后遍历,k==cnt时max就是赢家,或者到结束cnt都没到达k,那数组最大值max还是赢家
*/

class Solution {
    public int getWinner(int[] arr, int k) {
        int max=arr[0];//假设首位是max
        for(int i=1,cnt=0;i<arr.length;i++){
            if(max<arr[i]){//遍历数组 找到比max大的
                max=arr[i];//就更新max
                cnt=1;//并且更新当前赢的次数
            }else{
                cnt++;//不比max大,就说明它赢了一局,更新赢的次数
            }
            if(cnt==k){
                return max;//赢了k局就是赢家了
            }
        }
        return max;//从头到尾都没有赢家,那就返回数组最大值
    }
}
